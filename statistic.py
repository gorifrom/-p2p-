# -*- coding: utf-8 -*-
"""statistic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HMuNzyb2xuGe98C49Z5VZTJ2v0vRm7R7
"""

! pip install mesa

import numpy as np
import pandas as pd
from tqdm import tqdm
import scipy.stats as sts
import re
import datetime
import time

import matplotlib.pyplot as plt
import seaborn as sns
from pylab import rcParams

plt.style.use('fivethirtyeight')
rcParams['figure.figsize'] = 12, 6

import warnings
warnings.filterwarnings("ignore")
        
import mesa
import random



def compute_gini(model):
    agent_wealths = [agent.wealth for agent in model.schedule.agents]
    x = sorted(agent_wealths)
    N = model.num_agents
    B = sum(xi * (N - i) for i, xi in enumerate(x)) / (N * sum(x))
    return 1 + (1 / N) - 2 * B

class Agent(mesa.Agent):
    def __init__(self, unique_id, model, p, r):
        super().__init__(unique_id, model)
        self.p = p
        self.r = r
        # Бедные
        self.wealth = 0
        self.debitor = False
        # Богатые
        if sts.bernoulli.rvs(p) == 1:
            self.wealth = 500
            

    def step(self):
        # Базовый безусловный доход
        self.wealth += 5
        # Базовая аренда 40 каждые 10 дней
        if i % 10 == 0:
            self.wealth -= 40
        # Возврат кредита 50 если настало время возврата
        if self.debitor == True:
            if self.credit_time >= i:
                if sts.bernoulli.rvs(r) == 0:
                    self.creditor.wealth += 53
                    self.wealth -= 53
                    self.debitor = False
                else:
                    self.debitor = False
        # Кредиты только для бедных
        if self.wealth > 40:
        # Кредиты только для бедных
            return
        # Случайный партнер
        creditor = self.random.choice(self.model.schedule.agents)
        # Только богатый дает кредит
        if creditor.wealth < 200:
            return
        # Дает кредит 40, но вернуть надо 50 через 10 шагов
        creditor.wealth -= 40
        self.wealth += 40        
        # Надо вернуть 50 через 10 шагов
        self.debitor = True
        self.creditor = creditor
        self.credit_time = i + 10
        
class Model(mesa.Model):
    def __init__(self, N, p, r):
        self.num_agents = N
        self.schedule = mesa.time.RandomActivation(self)
        # Создать агентов
        for i in range(self.num_agents):
            a = Agent(i, self, p, r)
            self.schedule.add(a)
        # Создать дата-коллектор
        self.datacollector = mesa.DataCollector(
            model_reporters={"Gini": compute_gini}, 
            agent_reporters={"Wealth": "wealth"})

    def step(self):
        self.datacollector.collect(self)            
        self.schedule.step()

N = 100
N_step = 3000
p = 0.3
r = 0.16
model = Model(N, p, r)
            
for i in range(N_step):
    model.step()

gini = model.datacollector.get_model_vars_dataframe()
gini.plot();
plt.title(f'График устойчивости при p={p}, r={r}, n={N}, N={N_step}', pad=1);
plt.xlabel('Шаг моделирования (N)');
plt.ylabel('Коэффициент Джини(k)');

gini_0 = gini

gini_1 = gini

gini_2 = gini

gini_3 = gini

gini_4 = gini

plt.plot(gini_0, label='r=0.15, I = 0.35')
plt.plot(gini_1, label='r=0.15, I = 0.325')
plt.plot(gini_2, label='r=0.15, I = 0.3')
plt.plot(gini_3, label='r=0.15, I = 0.275')
plt.plot(gini_4, label='r=0.15, I = 0.25')

plt.title(f'График устойчивости при p={p}, n={N}, N={N_step}', pad=1.4);
plt.xlabel('Шаг моделирования(N)');
plt.ylabel('Коэффициент Джини (k)');
plt.legend();

import numpy as np
import pandas as pd 
import seaborn as sns

data = [
    [0.13, 0.49, 0.84, np.nan, np.nan, np.nan, np.nan, np.nan],
    [np.nan, 0.38, 0.51, 0.97, np.nan, np.nan, np.nan, np.nan],
    [np.nan, 0.25, 0.42, 0.67, np.nan, np.nan, np.nan, np.nan],
    [np.nan, 0.13, 0.32, 0.5, 0.87, np.nan, np.nan, np.nan],
    [np.nan, np.nan, 0.17, 0.43, 0.72, np.nan, np.nan, np.nan],
    [np.nan, np.nan, np.nan,  0.28, 0.52, 0.84, np.nan, np.nan],
    [np.nan, np.nan, np.nan, 0.16, 0.26, 0.57, 0.77, np.nan],
    [np.nan, np.nan, np.nan, 0.1, 0.13, 0.4, 0.71, np.nan]
]

# Создаем тепловую карту
fig, ax = plt.subplots()
sns.heatmap(
    data,
    annot=True,
    fmt="",
    cmap="coolwarm",
    linewidths=1,
    ax=ax,
    cbar=True,
    square=True,
)

# Настраиваем график
ax.set_xticklabels(["15", "17,5", "20", "22,5", "25", "27,5", "30", "32,5"])
ax.set_yticklabels(["0.09", "0.10", "0.11", "0.12", "0.13", "0.14", "0.15", "0.16"], rotation=0)
ax.set_xlabel("Процентная ставка кредита, I")
ax.set_ylabel("Коэффициент невозврата кредита, r")
plt.title("Тепловая карта устойчивости")

plt.show()

agent_wealth = model.datacollector.get_agent_vars_dataframe()
agent_wealth.head(60)

agent_wealth.xs(14, level="AgentID")

agent_wealth.info()

# agent_wealth = [a.wealth for a in ]
# plt.hist(agent_wealth);



"""Проведем статистическую проверку модели. Для этого выполним следующие шаги:

1. Сформулируем гипотезу:
Для начала, нужно определить, какую гипотезу мы хотим проверить. В нашем случае, это может быть связано с влиянием различных параметров модели (p, r, n, N) на коэффициент Джини.

2. Выбрать статистический критерий:
Следующим шагом является выбор статистического критерия для проверки гипотезы. Это может быть критерий t-теста Стьюдента, критерий Манна-Уитни, критерий хи-квадрат и т. д. Выбор критерия зависит от типа данных и распределения.

3. Вычислим p-значение:
После выбора статистического критерия, нужно вычислить p-значение, которое показывает вероятность получить наблюдаемые (или более экстремальные) результаты при условии, что нулевая гипотеза верна.

4. Сравним p-значение с уровнем значимости (α):
Зададим уровень значимости, обычно α = 0.05. Если p-значение меньше α, это свидетельствует в пользу альтернативной гипотезы, и вы можете сделать вывод о значимости эффекта.

"""

import numpy as np
import pandas as pd
from scipy import stats
import matplotlib.pyplot as plt
import seaborn as sns

"""Теперь, мы проверим гипотезу о влиянии коэффициента невозврата кредита (r) на коэффициент Джини. Сначала извлекаем данные по коэффициенту Джини для разных значений r:"""

r_values = np.linspace(0.1, 0.5, 5) 
gini_r = []
for r in r_values:
    model = Model(N, p, r)
    for i in range(N_step):
        model.step()
    gini = model.datacollector.get_model_vars_dataframe()
    gini_r.append(gini)



"""Теперь, используя критерий t-теста Стьюдента, сравним результаты для двух разных значений r:"""

t_stat, p_value = stats.ttest_ind(gini_r[0]["Gini"], gini_r[1]["Gini"])
print("t-статистика:", t_stat)
print("p-значение:", p_value)

"""Если p-значение меньше заданного уровня значимости (обычно 0.05), это означает, что мы можем отвергнуть нулевую гипотезу о равенстве средних значений коэффициента Джини для двух разных значений r. В этом случае, мы можем заключить, что коэффициент невозврата кредита (r) имеет статистически значимое влияние на коэффициент Джини.

Проанализируем влияние параметров p, n и N на коэффициент Джини.

1. Влияние параметра p (вероятность агента быть богатым):

Для анализа влияния параметра p на коэффициент Джини, мы можем сгенерировать серии с разными значениями p и сравнить полученные коэффициенты Джини.
"""

p_values = np.linspace(0.1, 0.5, 5)  # Генерация разных значений p
gini_p = []  # Список для хранения коэффициента Джини для каждого значения p

for p_value in p_values:
    model = Model(N, p_value, r)
    for i in range(N_step):
        model.step()  
    gini_current = model.datacollector.get_model_vars_dataframe()
    gini_p.append(gini_current)

t_stat, p_value = stats.ttest_ind(gini_p[0]["Gini"], gini_p[1]["Gini"])
print("t-статистика:", t_stat)
print("p-значение:", p_value)

"""2. Влияние параметра n (количество агентов):

Для анализа влияния параметра n на коэффициент Джини, мы можем сгенерировать серии с разным количеством агентов и сравнить полученные коэффициенты Джини.

"""

n_values = [50, 100, 150, 200, 250]  # Генерация разных значений n
gini_n = []  # Список для хранения коэффициента Джини для каждого значения n

for n_value in n_values:
    model = Model(n_value, p, r)
    for i in range(N_step):
        model.step()  
    gini_current = model.datacollector.get_model_vars_dataframe()
    gini_n.append(gini_current)

t_stat, p_value = stats.ttest_ind(gini_n[0]["Gini"], gini_n[1]["Gini"])
print("t-статистика:", t_stat)
print("p-значение:", p_value)

"""3. Влияние параметра N (количество шагов моделирования):

Для анализа влияния параметра N на коэффициент Джини, мы можем сгенерировать серии с разным количеством шагов моделирования и сравнить полученные коэффициенты Джини.

"""

N_step_values = [1000, 2000, 3000, 4000, 5000]  # Генерация разных значений N_step
gini_N = []  # Список для хранения коэффициента Джини для каждого значения N_step

for N_step_value in N_step_values:
    model = Model(N, p, r)
    for i in range(N_step_value):
        model.step()  
    gini_current = model.datacollector.get_model_vars_dataframe()
    gini_N.append(gini_current)

"""Теперь мы имеем следующие списки `gini_p`, `gini_n` и `gini_N`, которые содержат коэффициенты Джини для разных значений параметров p, n и N соответственно.

Также построим графики совместного распределения различных параметров и коэффициента Джини, чтобы визуализировать зависимости между ними. Для этого можно использовать библиотеку seaborn

"""

# Построение графика совместного распределения для коэффициента невозврата кредита (r) и коэффициента Джини
r_values = np.array(r_values)
gini_means = np.array([gini["Gini"].mean() for gini in gini_r])

sns.scatterplot(x=r_values, y=gini_means)
plt.xlabel("Коэффициент невозврата кредита (r)")
plt.ylabel("Средний коэффициент Джини")
plt.show()

"""После получения результатов коэффициента Джини для разных значений параметров p, n и N, мы можем проанализировать их с использованием статистических методов и визуализаций, чтобы понять, как они влияют на коэффициент Джини.

1. Влияние параметра p (вероятность агента быть богатым):

"""

plt.figure()
for i, gini_current in enumerate(gini_p):
    plt.plot(gini_current, label=f'p={p_values[i]:.1f}')
plt.title('Коэффициент Джини при разных значениях p')
plt.xlabel('Шаг моделирования (N)')
plt.ylabel('Коэффициент Джини (k)')
plt.legend()
plt.show()

"""
Вывод: График показывает, что при увеличении параметра p (вероятность агента быть богатым), коэффициент Джини имеет тенденцию увеличиваться. Это говорит о том, что с увеличением вероятности агента быть богатым, неравенство в распределении богатства среди агентов усиливается. Эта информация может быть использована для определения оптимальных значений параметра p, чтобы достичь меньшей степени неравенства в распределении богатства.

2. Влияние параметра n (количество агентов):
"""

plt.figure()
for i, gini_current in enumerate(gini_n):
    plt.plot(gini_current, label=f'n={n_values[i]}')
plt.title('Коэффициент Джини при разных значениях n')
plt.xlabel('Шаг моделирования (N)')
plt.ylabel('Коэффициент Джини (k)')
plt.legend()
plt.show()

"""Вывод: График показывает, что количество агентов (n) не имеет существенного влияния на коэффициент Джини. Однако, при больших значениях n, изменения коэффициента Джини могут быть более стабильными и меньше подвержены случайным колебаниям. Это может указывать на то, что для данной модели количество агентов не является ключевым параметром для оптимизации распределения богатства.

"""

plt.figure()
for i, gini_current in enumerate(gini_N):
    plt.plot(gini_current, label=f'N_step={N_step_values[i]}')
plt.title('Коэффициент Джини при разных значениях N_step')
plt.xlabel('Шаг моделирования (N)')
plt.ylabel('Коэффициент Джини (k)')
plt.legend()
plt.show()

"""Вывод: График показывает, что при увеличении числа шагов моделирования (N), коэффициент Джини сначала быстро изменяется, а затем стабилизируется и колеблется вокруг определенного значения. Это может указывать на то, что модель сходится к некоторому равновесному состоянию, и дополнительные шаги моделирования не обязательно приведут к значительным изменениям в распределении богатства. Однако, для анализа сходимости и определения оптимального числа шагов моделирования, вам могут потребоваться дополнительные методы и критерии остановки.

На основе этих выводов, можно сделать предположение о том, что оптимизация параметра p может быть наиболее полезным подходом для улучшения равномерности распределения богатства среди агентов.

Проверим влияние ставки кредита (I) на коэффициент Джини и распределение богатства среди агентов. Чтобы сделать это, включим этот параметр в нашу модель и провести аналогичный анализ влияния параметра, как и для p, n и N.

Для начала, предположим, что у нас есть функция, которая использует ставку кредита I в процессе моделирования:
"""

class ModelWithInterestRate(Model):
    def __init__(self, N, p, r, I):
        super().__init__(N, p, r)  # Вызываем инициализацию родительского класса
        self.I = I  # Добавляем ставку кредита в модель
        
    def step(self):
        # Используем ставку кредита в процессе моделирования
        # Заменяем 53 на (40 * (1 + self.I)) в коде агента
        for agent in self.schedule.agents:
            if agent.debitor:
                if agent.credit_time >= i:
                    if sts.bernoulli.rvs(agent.r) == 0:
                        agent.creditor.wealth += 40 * (1 + self.I)
                        agent.wealth -= 40 * (1 + self.I)
                        agent.debitor = False
                    else:
                        agent.debitor = False
        
        # Сбор данных и выполнение шага
        self.datacollector.collect(self)
        self.schedule.step()

"""Теперь мы можем провести анализ влияния ставки кредита I на коэффициент Джини, генерируя серии с разными значениями I:"""

I_values = np.linspace(0.1, 0.5, 5)  # Генерация разных значений I (ставка кредита)
gini_I = []  # Список для хранения коэффициента Джини для каждого значения I

for I_value in I_values:
    model = ModelWithInterestRate(N, p, r, I_value)
    for i in range(N_step):
        model.step()
    gini_current = model.datacollector.get_model_vars_dataframe()
    gini_I.append(gini_current)

"""Теперь у вас есть список gini_I, который содержит коэффициенты Джини для разных значений ставки кредита I. Мы можем проанализировать результаты с использованием статистических методов и визуализаций, например, построив график изменения коэффициента Джини в зависимости от ставки кредита I:"""

plt.figure()
for i, gini_current in enumerate(gini_I):
    plt.plot(gini_current, label=f'I={I_values[i]:.1f}')
plt.title('Коэффициент Джини при разных значениях ставки кредита I')
plt.xlabel('Шаг моделирования (N)')
plt.ylabel('Коэффициент Джини (k)')
plt.legend()
plt.show()

"""На основе полученного графика и статистического анализа мы можем сделать выводы о том, как ставка кредита I влияет на коэффициент Джини и распределение богатства."""

# Сценарий с регулятором

def run_model_with_different_N_and_n(N_values, n_values, p, r):
    results = []

    for N in N_values:
        for n in n_values:
            model = Model(N, p, r)
            for i in range(n):
                model.step()
            gini = model.datacollector.get_model_vars_dataframe().iloc[-1]['Gini']
            results.append((N, n, gini))

    return results

N_values = [50, 100, 150, 200]
n_values = [1000, 2000, 3000, 4000]
p = 0.3
r = 0.16
s = 1

results = run_model_with_different_N_and_n(N_values, n_values, p, r,s)

import pandas as pd

df = pd.DataFrame(results, columns=['N', 'n', 'Gini'])

"""Теперь проведем t-тесты для N и n:"""

ttest_N_results = []
for N in N_values:
    df_N1 = df[df['N'] == N]
    for N2 in N_values:
        if N2 > N:
            df_N2 = df[df['N'] == N2]
            t_stat, p_value = ttest_ind(df_N1['Gini'], df_N2['Gini'])
            ttest_N_results.append((N, N2, t_stat, p_value))

ttest_n_results = []
for n in n_values:
    df_n1 = df[df['n'] == n]
    for n2 in n_values:
        if n2 > n:
            df_n2 = df[df['n'] == n2]
            t_stat, p_value = ttest_ind(df_n1['Gini'], df_n2['Gini'])
            ttest_n_results.append((n, n2, t_stat, p_value))

ttest_n_results = []
for s in s_values:
    df_s1 = df[df['s'] == s]
    for s2 in s_values:
        if s2 > s:
            df_s2 = df[df['s'] == s2]
            t_stat, p_value = ttest_ind(df_s1['Gini'], df_s2['Gini'])
            ttest_s_results.append((s, s2, t_stat, p_value))

print("T-test results for N:")
for result in ttest_N_results:
    print(f"N1: {result[0]}, N2: {result[1]}, t-stat: {result[2]:.2f}, p-value: {result[3]:.6f}")

print("\nT-test results for n:")
for result in ttest_n_results:
    print(f"n1: {result[0]}, n2: {result[1]}, t-stat: {result[2]:.2f}, p-value: {result[3]:.6f}")